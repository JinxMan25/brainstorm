<!DOCTYPE html>
<%= stylesheet_link_tag "test" %>
    <div id="update">
        <input name="updateButton" type="button" value="Update" onclick="newData()"/>
    </div>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script>

    var width = 960,
        height = 500;

    var force = d3.layout.force()
        .size([width, height])
        .linkDistance(150)
        .charge(-300)
        .on("tick", tick);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .style("border", "1px solid black");

        var dataset = <%= @nodes.to_json.html_safe %>

    var link = svg.append("g").selectAll(".link"),
    circle = svg.append("g").selectAll("circle"),
    text = svg.append("g").selectAll("text"),
    body = svg.append("g").selectAll("text"),
    marker = svg.append("defs").selectAll("marker");

    var nodes = {};

    update(dataset);

    function newData()
    {
      var newDataset = <%= @nodes2.to_json.html_safe %>

        update(newDataset);
    }

    function update(links)
    {
        d3.values(nodes).forEach(function(aNode){ aNode.linkCount = 0;});
            // Reset the link count for all existing nodes by
            // creating an array out of the nodes list, and then calling a function
            // on each node to set the linkCount property to zero.

        // Compute the distinct nodes from the links.
        links.forEach(function(link)
        {
            link.source = nodes[link.source] || (nodes[link.source] = {name: link.source, linkCount:0});    // initialize new nodes with zero links
            link.source.linkCount++;
                // record this link on the source node, whether it was just initialized
                // or already in the list, by incrementing the linkCount property
                // (remember, link.source is just a reference to the node object in the
                // nodes array, when you change its properties you change the node itself.)

            link.target = nodes[link.target] || (nodes[link.target] = {name: link.target, linkCount:0});    // initialize new nodes with zero links

            link.target.linkCount++;
        });

        d3.keys(nodes).forEach(
            // create an array of all the current keys(names) in the node list,
            // and then for each one:

            function (nodeKey)
            {
                if (!nodes[nodeKey].linkCount)
                {
                    // find the node that matches that key, and check it's linkCount value
                    // if the value is zero (false in Javascript), then the ! (NOT) operator
                    // will reverse that to make the if-statement return true,
                    // and the following will execute:

                    delete(nodes[nodeKey]);
                        //this deletes the object AND its key from the nodes array
                 }
             }
         );

        force
            .nodes(d3.values(nodes))
            .links(links)
            .start();

        // -------------------------------

        // Compute the data join. This returns the update selection.
                // Compute new attributes for entering and updating markers.
        

        // -------------------------------

        // Compute the data join. This returns the update selection.
        link = link.data(force.links());

        // Remove any outgoing/old paths.
        link.exit().remove();

        // Compute new attributes for entering and updating paths.
        link.enter().append("line")
            .attr("class", function(d) { return "link " + d.type; })
            .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });
            

        // -------------------------------

        // Compute the data join. This returns the update selection.
        circle = circle.data(force.nodes());

        // Add any incoming circles.
        var newg = circle.enter().append("g").call(force.drag);

        var newnode = newg.append("circle");
        circle.exit().remove();
        circle.select("text").remove();

        var textnode = circle.append("text")
          .text(function(d){ return d.name; });
        // Remove any outgoing/old circles.

        // Compute new attributes for entering and updating circles.
        newnode
            .attr("r", 39)
            .attr("stroke", "black")
            .attr("stroke-width", 1.5)
            .on("click", click);

        // -------------------------------

        // Compute the data join. This returns the update selection.

    }

    // Use elliptical arc path segments to doubly-encode directionality.
    function tick()
    {
        link
          .attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });
        circle.attr("transform", transform);
        text.attr("transform", transform);
    }

  function click(){
    
    if (d3.select(this).attr("r") > 100) {
      force
        .gravity(0.1)
        .linkDistance(150)
        .charge(-600)
        .start();
      
      $(".addnode").removeClass("translate");
      d3.select(this).transition()
        .duration(1000)
        .attr("r", function(d){
          if (d.weight == "1"){
            return 28;
          }else if (d.weight == "2") {
            return 17.5 * d.weight;
          }else if (d.weight == "3") {
            return 13 * d.weight;
          }else if (d.weight == "4") {
            return 11 * d.weight;
          }else if (d.weight == "5") {
            return 10* d.weight;
          }else if (d.weight == "6"){
            return 7 * d.weight;
          }else if (d.weight >= "7"){
            return 6.5 * d.weight;
          }
        })
        .attr("stroke","black")
        .attr("stroke-width",1.5);
        
    } else {
      d3.selectAll("circle").transition()
        .duration(1000)
        .attr("r", function(d){
          if (d.weight == "1") {
            return 28;
          } else if (d.weight == "2") {
              return 17.5 * d.weight;
          } else if (d.weight == "3") {
              return 13 * d.weight;
          } else if (d.weight == "4") {
              return 11 * d.weight;
          } else if (d.weight == "5"){
              return 10* d.weight;
          } else if (d.weight == "6"){
              return 7 * d.weight;
          } else if (d.weight >= "7"){
              return 6.5 * d.weight;
          }
        })
        .attr("stroke-width", 1.5)
        .attr("stroke", "black");
      d3.selectAll("text").transition()
        .duration(750)
        .style("font-size", "15px")
        .ease("elastic")
        .attr("dy",".20em");
      d3.select(this).transition()
        .ease("elastic")
        .duration(2500)
        .attr("r", 250)
        .attr("stroke-width", 10)
        .attr("stroke", "purple");
      d3.select(this).select("text").transition()
        .duration(2500)
        .style("font-size", "72px")
        .ease("elastic")
        .attr("dy", "-100px");
        
      }
  }

    function transform(d)
    {
        return "translate(" + d.x + "," + d.y + ")";
    }

    </script>
